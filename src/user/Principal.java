package user;

import cup.sym;
import flex.Errors;
import flex.Token;
import flex.LexiconParser;
import flex.SyntacticParser;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import static java.lang.System.exit;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.SwingUtilities;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyleContext;
import javax.swing.text.StyledDocument;

/**
 *
 * @author Dayana Toledo e Gabriela Tamashiro
 */
public class Principal extends javax.swing.JFrame {

    private final CustomDocumentFilter myDocumentFilter;
    private ArrayList<Errors> errors;
    private ArrayList<Token> tokens;
    private int size;

    public static void main(String args[]) {
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }

        java.awt.EventQueue.invokeLater(() -> {
            new Principal().setVisible(true);
        });
    }

    public Principal() {
        initComponents();
        myDocumentFilter = new CustomDocumentFilter();
        TextLineComponent textLine = new TextLineComponent(codeTextarea);
        codeScrollPanel.setRowHeaderView(textLine);
        errors = new ArrayList<>();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        codeScrollPanel = new javax.swing.JScrollPane();
        codeTextarea = new javax.swing.JTextPane();
        tabPanelBottom = new javax.swing.JTabbedPane();
        tokensPanel = new javax.swing.JPanel();
        tokensScrollPanel = new javax.swing.JScrollPane();
        tokensTable = new javax.swing.JTable();
        errorsPanel = new javax.swing.JPanel();
        errorsScrollPanel = new javax.swing.JScrollPane();
        errorsTable = new javax.swing.JTable();
        menuBarTop = new javax.swing.JMenuBar();
        menuFile = new javax.swing.JMenu();
        itemLoadFile = new javax.swing.JMenuItem();
        menuExecutar = new javax.swing.JMenu();
        itemLexiconParser = new javax.swing.JMenuItem();
        itemSyntacticParser = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setLocation(new java.awt.Point(0, 0));

        codeTextarea.setFont(new java.awt.Font("Monospaced", 0, 13)); // NOI18N
        codeTextarea.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                codeTextareaKeyReleased(evt);
            }
        });
        codeScrollPanel.setViewportView(codeTextarea);

        tokensTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Lexema", "Token", "Linha", "Coluna Inicial", "Coluna Final", "Error"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tokensScrollPanel.setViewportView(tokensTable);

        javax.swing.GroupLayout tokensPanelLayout = new javax.swing.GroupLayout(tokensPanel);
        tokensPanel.setLayout(tokensPanelLayout);
        tokensPanelLayout.setHorizontalGroup(
            tokensPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tokensScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 849, Short.MAX_VALUE)
        );
        tokensPanelLayout.setVerticalGroup(
            tokensPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tokensScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 252, Short.MAX_VALUE)
        );

        tabPanelBottom.addTab("Tokens da linguagem", tokensPanel);

        errorsTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Especificação do erro", "Linha", "Coluna"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        errorsScrollPanel.setViewportView(errorsTable);

        javax.swing.GroupLayout errorsPanelLayout = new javax.swing.GroupLayout(errorsPanel);
        errorsPanel.setLayout(errorsPanelLayout);
        errorsPanelLayout.setHorizontalGroup(
            errorsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(errorsScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 849, Short.MAX_VALUE)
        );
        errorsPanelLayout.setVerticalGroup(
            errorsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(errorsScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 252, Short.MAX_VALUE)
        );

        tabPanelBottom.addTab("Erros ocorridos", errorsPanel);

        menuFile.setText("Arquivo");
        menuFile.setToolTipText("");
        menuFile.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        menuFile.setVerifyInputWhenFocusTarget(true);

        itemLoadFile.setText("Abrir arquivo");
        itemLoadFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                itemLoadFileActionPerformed(evt);
            }
        });
        menuFile.add(itemLoadFile);

        menuBarTop.add(menuFile);

        menuExecutar.setText("Executar");

        itemLexiconParser.setText("Analisador Léxico");
        itemLexiconParser.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                itemLexiconParserActionPerformed(evt);
            }
        });
        menuExecutar.add(itemLexiconParser);

        itemSyntacticParser.setText("Analisador Sintático");
        itemSyntacticParser.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                itemSyntacticParserActionPerformed(evt);
            }
        });
        menuExecutar.add(itemSyntacticParser);

        menuBarTop.add(menuExecutar);

        setJMenuBar(menuBarTop);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(tabPanelBottom)
                    .addComponent(codeScrollPanel))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(codeScrollPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 298, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(27, 27, 27)
                .addComponent(tabPanelBottom)
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void codeTextareaKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_codeTextareaKeyReleased
        int newfontSize = codeTextarea.getText().length();
        if (size != newfontSize) {
            myDocumentFilter.ignoredTokens = null;
            size = newfontSize;
        }
        myDocumentFilter.updateTextStyles();
        codeTextarea.repaint();
    }//GEN-LAST:event_codeTextareaKeyReleased

    private void itemLoadFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_itemLoadFileActionPerformed
        JFileChooser loadFile = new JFileChooser();
        loadFile.setFileFilter(new FilterFile());

        int opcao;
        opcao = loadFile.showOpenDialog(null);
        if (opcao == JFileChooser.APPROVE_OPTION) {
            File file = loadFile.getSelectedFile();
            try {
                Scanner reader = new Scanner(file);
                String line = "";
                while (reader.hasNext()) {
                    line += reader.nextLine() + System.lineSeparator();
                }
                codeTextarea.setText(line);
            } catch (FileNotFoundException ex) {
                exit(1);
            }
            myDocumentFilter.updateTextStyles();
            codeTextarea.repaint();
        }
    }//GEN-LAST:event_itemLoadFileActionPerformed

    private void itemLexiconParserActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_itemLexiconParserActionPerformed
        this.getAllTokens();
        this.fillLexiconTable(tokens);
    }//GEN-LAST:event_itemLexiconParserActionPerformed

    private void itemSyntacticParserActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_itemSyntacticParserActionPerformed
        this.getAllErrorsAndTokens();
        this.fillLexiconTable(tokens);
        this.fillSyntacticTable(errors);
        this.myDocumentFilter.updateTextStyles();
        tabPanelBottom.setSelectedIndex(1);
        repaint();
    }//GEN-LAST:event_itemSyntacticParserActionPerformed

    public void fillLexiconTable(ArrayList<Token> tokens) {
        DefaultTableModel dtm = (DefaultTableModel) tokensTable.getModel();
        dtm.getDataVector().removeAllElements();
        dtm.fireTableDataChanged();

        String[] rowTable = new String[6];

        TableCellRenderer tcr = new PaintTableCellRenderer();
        tokensTable.setDefaultRenderer(Object.class, tcr);

        for (Token currentToken : tokens) {
            rowTable[0] = currentToken.getLexeme();
            rowTable[1] = currentToken.getTokenName();
            rowTable[2] = String.valueOf(currentToken.getRow());
            rowTable[3] = String.valueOf(currentToken.getColumnStart());
            rowTable[4] = String.valueOf(currentToken.getColumnEnd());
            rowTable[5] = String.valueOf(currentToken.getIsWrong());
            dtm.addRow(rowTable);
        }
        tokensTable.revalidate();
        tokensTable.repaint();
    }

    public void fillSyntacticTable(ArrayList<Errors> errors) {
        DefaultTableModel dtm = (DefaultTableModel) errorsTable.getModel();
        dtm.getDataVector().removeAllElements();
        dtm.fireTableDataChanged();

        String[] rowTable = new String[3];
        for (Errors currentError : errors) {
            rowTable[2] = String.valueOf(currentError.getColumn());
            rowTable[1] = String.valueOf(currentError.getRow());
            rowTable[0] = currentError.getError();
            dtm.addRow(rowTable);
        }
        errorsTable.revalidate();
        errorsTable.repaint();
    }

    public void getAllTokens() {
        Token current;
        LexiconParser parser = new LexiconParser(new StringReader(codeTextarea.getText()));
        tokens = new ArrayList<>();

        try {
            while (true) {
                parser.next_token();
                current = parser.yylex();
                if (current.getToken() == sym.EOF) {
                    break;
                } else {
                    tokens.add(current);
                }
            }
        } catch (IOException ex) {
            Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public void getAllErrorsAndTokens() {
        errors = new ArrayList<>();
        tokens = new ArrayList<>();
        SyntacticParser parser = new SyntacticParser(new CustomScanner((new StringReader(codeTextarea.getText())), tokens), errors);

        try {
            Boolean response = parser.start();
            System.out.println(response);
        } catch (Exception ex) {
            Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
        }

        myDocumentFilter.ignoredTokens = parser.getTokenIgnorados();
    }

    private class PaintTableCellRenderer extends DefaultTableCellRenderer {

        @Override
        public Component getTableCellRendererComponent(
                JTable table,
                Object value,
                boolean isSelected,
                boolean hasFocus,
                int row,
                int column
        ) {
            super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

            Boolean isWrong = Boolean.valueOf((String)table.getValueAt(row, 5));
            Color lightGrayColor = new Color(240, 240, 240);
            Color blackColor = new Color(40, 40, 40);
            
            if (isWrong == true) {
                setBackground(Color.RED);
                setForeground(Color.WHITE);
            } else {
                if (isSelected == true) {
                    setBackground(getBackground());
                    setForeground(getForeground());
                } else {
                    if (row % 2 == 0) {
                        setBackground(Color.WHITE);
                    } else {
                        setBackground(lightGrayColor);
                    }
                    setForeground(blackColor);
                }
            }
            return this;
        }
    }

    private class CustomDocumentFilter extends DocumentFilter {

        private final StyledDocument styledDocument = codeTextarea.getStyledDocument();
        private final StyleContext styleContext = StyleContext.getDefaultStyleContext();
        private ArrayList<Token> ignoredTokens;
        private final AttributeSet blueAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.BLUE);
        private final AttributeSet blackAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.BLACK);
        private final AttributeSet greenAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, new Color(0, 153, 0));
        private final AttributeSet redAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.RED);
        private final AttributeSet pinkAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, new Color(255, 0, 255));
        private final AttributeSet grayAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.gray);

        @Override
        public void insertString(DocumentFilter.FilterBypass fb, int offset, String text, AttributeSet attributeSet) throws BadLocationException {
            super.insertString(fb, offset, text, attributeSet);
            handleTextChanged();
        }

        @Override
        public void remove(DocumentFilter.FilterBypass fb, int offset, int length) throws BadLocationException {
            super.remove(fb, offset, length);
            handleTextChanged();
        }

        @Override
        public void replace(DocumentFilter.FilterBypass fb, int offset, int length, String text, AttributeSet attributeSet) throws BadLocationException {
            super.replace(fb, offset, length, text, attributeSet);
            handleTextChanged();
        }

        /**
         * Runs your updates later, not during the event notification.
         */
        private void handleTextChanged() {
            SwingUtilities.invokeLater(() -> {
                updateTextStyles();
            });
        }

        private void updateTextStyles() {
            // Clear existing styles
            styledDocument.setCharacterAttributes(0, codeTextarea.getText().length(), blackAttributeSet, true);
            LexiconParser parser = new LexiconParser(new StringReader(codeTextarea.getText()));
            ArrayList<Token> tokensCopy = (ignoredTokens != null ? (ArrayList<Token>) ignoredTokens.clone() : null);
            parser.tokens(true);
            Token currentToken;

            while (true) {
                currentToken = parser.yylex();
                if (currentToken.getToken() == sym.EOF) {
                    break;
                }
                AttributeSet ts = blackAttributeSet;
                if (currentToken.getToken() >= 2 && currentToken.getToken() <= 15) {
                    ts = blueAttributeSet;
                } else if ((currentToken.getToken() >= 22 && currentToken.getToken() <= 34)) {
                    ts = redAttributeSet;
                } else if (currentToken.getToken() == 35 || currentToken.getToken() == 36) {
                    ts = pinkAttributeSet;
                } else if (currentToken.getToken() == 37) {
                    ts = greenAttributeSet;
                } else if (currentToken.getToken() >= 40 && currentToken.getToken() <= 42) {
                    ts = grayAttributeSet;
                }
                if (ignoredTokens != null && ignoredTokens.contains(currentToken)) {
                    ignoredTokens.remove(currentToken);
                    ts = styleContext.addAttribute(ts, StyleConstants.Underline, true);
                }
                styledDocument.setCharacterAttributes(
                        currentToken.getOffset() - currentToken.getRow(),
                        currentToken.getLexeme().length(),
                        ts,
                        false
                );
            }
            ignoredTokens = tokensCopy;
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane codeScrollPanel;
    private javax.swing.JTextPane codeTextarea;
    private javax.swing.JPanel errorsPanel;
    private javax.swing.JScrollPane errorsScrollPanel;
    private javax.swing.JTable errorsTable;
    private javax.swing.JMenuItem itemLexiconParser;
    private javax.swing.JMenuItem itemLoadFile;
    private javax.swing.JMenuItem itemSyntacticParser;
    private javax.swing.JMenuBar menuBarTop;
    private javax.swing.JMenu menuExecutar;
    private javax.swing.JMenu menuFile;
    private javax.swing.JTabbedPane tabPanelBottom;
    private javax.swing.JPanel tokensPanel;
    private javax.swing.JScrollPane tokensScrollPanel;
    private javax.swing.JTable tokensTable;
    // End of variables declaration//GEN-END:variables
}
