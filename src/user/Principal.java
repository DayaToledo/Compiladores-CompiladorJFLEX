package user;

import cup.sym;
import syntacticAndSemantic.Errors;
import lexicon.Token;
import lexicon.LexiconParser;
import syntacticAndSemantic.SyntacticParser;
import interpreter.IO;
import interpreter.Interpreter;
import java.awt.Color;
import java.awt.Component;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import static java.lang.System.exit;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.SwingUtilities;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyleContext;
import javax.swing.text.StyledDocument;
import machineCode.Instruction;

/**
 *
 * @author Dayana Toledo e Gabriela Tamashiro
 */
public class Principal extends javax.swing.JFrame implements IO {

    private final CustomDocumentFilter myDocumentFilter;
    private ArrayList<Errors> errors;
    private ArrayList<Token> tokens;
    private ArrayList<Instruction> machineCode;
    private int size;

    public static void main(String args[]) {
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }

        java.awt.EventQueue.invokeLater(() -> {
            new Principal().setVisible(true);
        });
    }

    public Principal() {
        initComponents();
        myDocumentFilter = new CustomDocumentFilter();
        TextLineComponent textLine = new TextLineComponent(codeTextarea);
        codeScrollPanel.setRowHeaderView(textLine);
        errors = new ArrayList<>();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        codeScrollPanel = new javax.swing.JScrollPane();
        codeTextarea = new javax.swing.JTextPane();
        tabPanelBottom = new javax.swing.JTabbedPane();
        tokensPanel = new javax.swing.JPanel();
        tokensScrollPanel = new javax.swing.JScrollPane();
        tokensTable = new javax.swing.JTable();
        errorsPanel = new javax.swing.JPanel();
        errorsScrollPanel = new javax.swing.JScrollPane();
        errorsTable = new javax.swing.JTable();
        machinePanel = new javax.swing.JPanel();
        machineScrollPanel = new javax.swing.JScrollPane();
        machineCodeTable = new javax.swing.JTable();
        executionPanel = new javax.swing.JPanel();
        executionScrollPanel = new javax.swing.JScrollPane();
        executionTextArea = new javax.swing.JTextArea();
        menuBarTop = new javax.swing.JMenuBar();
        menuFile = new javax.swing.JMenu();
        itemLoadFile = new javax.swing.JMenuItem();
        menuExecutar = new javax.swing.JMenu();
        itemLexiconParser = new javax.swing.JMenuItem();
        itemSyntacticParser = new javax.swing.JMenuItem();
        itemMachineCode = new javax.swing.JMenuItem();
        itemInterpreter = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setLocation(new java.awt.Point(0, 0));

        codeTextarea.setFont(new java.awt.Font("Monospaced", 0, 13)); // NOI18N
        codeTextarea.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                codeTextareaKeyPressed(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                codeTextareaKeyReleased(evt);
            }
        });
        codeScrollPanel.setViewportView(codeTextarea);

        tokensTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Lexema", "Token", "Linha", "Coluna Inicial", "Coluna Final", "Error"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tokensScrollPanel.setViewportView(tokensTable);
        if (tokensTable.getColumnModel().getColumnCount() > 0) {
            tokensTable.getColumnModel().getColumn(2).setMinWidth(80);
            tokensTable.getColumnModel().getColumn(2).setPreferredWidth(80);
            tokensTable.getColumnModel().getColumn(2).setMaxWidth(80);
            tokensTable.getColumnModel().getColumn(3).setMinWidth(100);
            tokensTable.getColumnModel().getColumn(3).setPreferredWidth(100);
            tokensTable.getColumnModel().getColumn(3).setMaxWidth(100);
            tokensTable.getColumnModel().getColumn(4).setMinWidth(100);
            tokensTable.getColumnModel().getColumn(4).setPreferredWidth(100);
            tokensTable.getColumnModel().getColumn(4).setMaxWidth(100);
            tokensTable.getColumnModel().getColumn(5).setMinWidth(80);
            tokensTable.getColumnModel().getColumn(5).setPreferredWidth(80);
            tokensTable.getColumnModel().getColumn(5).setMaxWidth(80);
        }

        javax.swing.GroupLayout tokensPanelLayout = new javax.swing.GroupLayout(tokensPanel);
        tokensPanel.setLayout(tokensPanelLayout);
        tokensPanelLayout.setHorizontalGroup(
            tokensPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tokensScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 849, Short.MAX_VALUE)
        );
        tokensPanelLayout.setVerticalGroup(
            tokensPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tokensScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 252, Short.MAX_VALUE)
        );

        tabPanelBottom.addTab("Tokens da linguagem", tokensPanel);

        errorsTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Especificação do erro", "Linha", "Coluna"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        errorsScrollPanel.setViewportView(errorsTable);
        if (errorsTable.getColumnModel().getColumnCount() > 0) {
            errorsTable.getColumnModel().getColumn(1).setMinWidth(80);
            errorsTable.getColumnModel().getColumn(1).setPreferredWidth(80);
            errorsTable.getColumnModel().getColumn(1).setMaxWidth(80);
            errorsTable.getColumnModel().getColumn(2).setMinWidth(80);
            errorsTable.getColumnModel().getColumn(2).setPreferredWidth(80);
            errorsTable.getColumnModel().getColumn(2).setMaxWidth(80);
        }

        javax.swing.GroupLayout errorsPanelLayout = new javax.swing.GroupLayout(errorsPanel);
        errorsPanel.setLayout(errorsPanelLayout);
        errorsPanelLayout.setHorizontalGroup(
            errorsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(errorsScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 849, Short.MAX_VALUE)
        );
        errorsPanelLayout.setVerticalGroup(
            errorsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(errorsScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 252, Short.MAX_VALUE)
        );

        tabPanelBottom.addTab("Erros ocorridos", errorsPanel);

        machineCodeTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Rótulo", "Instrução", "Operador"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, true, true
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        machineScrollPanel.setViewportView(machineCodeTable);

        javax.swing.GroupLayout machinePanelLayout = new javax.swing.GroupLayout(machinePanel);
        machinePanel.setLayout(machinePanelLayout);
        machinePanelLayout.setHorizontalGroup(
            machinePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(machineScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 849, Short.MAX_VALUE)
        );
        machinePanelLayout.setVerticalGroup(
            machinePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(machineScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 252, Short.MAX_VALUE)
        );

        tabPanelBottom.addTab("Código de máquina", machinePanel);

        executionTextArea.setEditable(false);
        executionTextArea.setColumns(20);
        executionTextArea.setRows(5);
        executionScrollPanel.setViewportView(executionTextArea);

        javax.swing.GroupLayout executionPanelLayout = new javax.swing.GroupLayout(executionPanel);
        executionPanel.setLayout(executionPanelLayout);
        executionPanelLayout.setHorizontalGroup(
            executionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(executionScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 849, Short.MAX_VALUE)
        );
        executionPanelLayout.setVerticalGroup(
            executionPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(executionPanelLayout.createSequentialGroup()
                .addComponent(executionScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 239, Short.MAX_VALUE)
                .addContainerGap())
        );

        tabPanelBottom.addTab("Saida da execução", executionPanel);

        menuFile.setText("Arquivo");
        menuFile.setToolTipText("");
        menuFile.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        menuFile.setVerifyInputWhenFocusTarget(true);

        itemLoadFile.setText("Abrir arquivo");
        itemLoadFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                itemLoadFileActionPerformed(evt);
            }
        });
        menuFile.add(itemLoadFile);

        menuBarTop.add(menuFile);

        menuExecutar.setText("Executar");

        itemLexiconParser.setText("Analisador Léxico");
        itemLexiconParser.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                itemLexiconParserActionPerformed(evt);
            }
        });
        menuExecutar.add(itemLexiconParser);

        itemSyntacticParser.setText("Analisador Sintático e Semântico");
        itemSyntacticParser.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                itemSyntacticParserActionPerformed(evt);
            }
        });
        menuExecutar.add(itemSyntacticParser);

        itemMachineCode.setText("Código de máquina");
        itemMachineCode.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                itemMachineCodeActionPerformed(evt);
            }
        });
        menuExecutar.add(itemMachineCode);

        itemInterpreter.setText("Interpretador (compilar e executar)");
        itemInterpreter.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                itemInterpreterActionPerformed(evt);
            }
        });
        menuExecutar.add(itemInterpreter);

        menuBarTop.add(menuExecutar);

        setJMenuBar(menuBarTop);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(tabPanelBottom)
                    .addComponent(codeScrollPanel))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(codeScrollPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 298, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(27, 27, 27)
                .addComponent(tabPanelBottom)
                .addContainerGap())
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void codeTextareaKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_codeTextareaKeyReleased
        int newfontSize = codeTextarea.getText().length();
        if (size != newfontSize) {
            myDocumentFilter.ignoredTokens = null;
            size = newfontSize;
        }
        myDocumentFilter.updateTextStyles();
        codeTextarea.repaint();
    }//GEN-LAST:event_codeTextareaKeyReleased

    private void itemLoadFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_itemLoadFileActionPerformed
        JFileChooser loadFile = new JFileChooser();
        loadFile.setFileFilter(new FilterFile());

        int opcao;
        opcao = loadFile.showOpenDialog(null);
        if (opcao == JFileChooser.APPROVE_OPTION) {
            File file = loadFile.getSelectedFile();
            try {
                Scanner reader = new Scanner(file);
                String line = "";
                while (reader.hasNext()) {
                    line += reader.nextLine() + System.lineSeparator();
                }
                codeTextarea.setText(line);
            } catch (FileNotFoundException ex) {
                exit(1);
            }
            myDocumentFilter.updateTextStyles();
            codeTextarea.repaint();
        }
    }//GEN-LAST:event_itemLoadFileActionPerformed

    private void itemLexiconParserActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_itemLexiconParserActionPerformed
        this.getAllTokens();
        this.clearPanels();
        this.fillLexiconTable();
    }//GEN-LAST:event_itemLexiconParserActionPerformed

    private void itemSyntacticParserActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_itemSyntacticParserActionPerformed
        this.getAllErrorsAndTokens();
        this.clearPanels();
        this.fillLexiconTable();
        this.fillSyntacticTable();
        this.myDocumentFilter.updateTextStyles();
        tabPanelBottom.setSelectedIndex(1);
        repaint();
    }//GEN-LAST:event_itemSyntacticParserActionPerformed

    private void itemMachineCodeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_itemMachineCodeActionPerformed
        SyntacticParser parser = this.getAllErrorsAndTokens();
        this.getMachineCode(parser);
        this.clearPanels();
        this.fillLexiconTable();
        this.fillSyntacticTable();
        this.fillMachineCodeTable();
        this.myDocumentFilter.updateTextStyles();
        repaint();
    }//GEN-LAST:event_itemMachineCodeActionPerformed

    private void itemInterpreterActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_itemInterpreterActionPerformed
        SyntacticParser parser = this.getAllErrorsAndTokens();
        this.getMachineCode(parser);
        this.clearPanels();
        this.fillLexiconTable();
        this.fillSyntacticTable();
        this.fillMachineCodeTable();
        this.getInterpreter(parser);
        this.myDocumentFilter.updateTextStyles();
        repaint();
    }//GEN-LAST:event_itemInterpreterActionPerformed

    private void codeTextareaKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_codeTextareaKeyPressed
        // TODO add your handling code here:
    }//GEN-LAST:event_codeTextareaKeyPressed

    public void clearPanels() {
        DefaultTableModel dtm;

        dtm = (DefaultTableModel) tokensTable.getModel();
        dtm.getDataVector().removeAllElements();
        dtm.fireTableDataChanged();
        tokensTable.revalidate();
        tokensTable.repaint();

        dtm = (DefaultTableModel) errorsTable.getModel();
        dtm.getDataVector().removeAllElements();
        dtm.fireTableDataChanged();
        errorsTable.revalidate();
        errorsTable.repaint();

        dtm = (DefaultTableModel) machineCodeTable.getModel();
        dtm.getDataVector().removeAllElements();
        dtm.fireTableDataChanged();
        machineCodeTable.revalidate();
        machineCodeTable.repaint();

        executionTextArea.setText("");
    }

    public void fillLexiconTable() {
        DefaultTableModel dtm = (DefaultTableModel) tokensTable.getModel();
        dtm.getDataVector().removeAllElements();
        dtm.fireTableDataChanged();

        String[] rowTable = new String[6];

        TableCellRenderer tcr = new PaintTableCellRenderer();
        tokensTable.setDefaultRenderer(Object.class, tcr);

        for (Token currentToken : tokens) {
            rowTable[0] = currentToken.getLexeme();
            rowTable[1] = currentToken.getTokenName();
            rowTable[2] = String.valueOf(currentToken.getRow());
            rowTable[3] = String.valueOf(currentToken.getColumnStart());
            rowTable[4] = String.valueOf(currentToken.getColumnEnd());
            rowTable[5] = String.valueOf(currentToken.getIsWrong());
            dtm.addRow(rowTable);
        }
        tokensTable.revalidate();
        tokensTable.repaint();
    }

    public void fillSyntacticTable() {
        DefaultTableModel dtm = (DefaultTableModel) errorsTable.getModel();
        dtm.getDataVector().removeAllElements();
        dtm.fireTableDataChanged();

        String[] rowTable = new String[3];
        for (Errors currentError : errors) {
            rowTable[2] = String.valueOf(currentError.getColumn());
            rowTable[1] = String.valueOf(currentError.getRow());
            rowTable[0] = currentError.getError();
            dtm.addRow(rowTable);
        }
        errorsTable.revalidate();
        errorsTable.repaint();
    }

    public void fillMachineCodeTable() {
        if (errors.isEmpty()) {
            DefaultTableModel dtm = (DefaultTableModel) machineCodeTable.getModel();
            dtm.getDataVector().removeAllElements();
            dtm.fireTableDataChanged();

            String[] rowTable = new String[3];
            for (Instruction currentCode : machineCode) {
                rowTable[0] = currentCode.getLabelStr();
                rowTable[1] = currentCode.getInstruction();
                rowTable[2] = currentCode.getOperateStr();
                dtm.addRow(rowTable);
            }
            machineCodeTable.revalidate();
            machineCodeTable.repaint();

            tabPanelBottom.setSelectedIndex(2);
        } else {
            tabPanelBottom.setSelectedIndex(1);
        }
    }

    public void getAllTokens() {
        Token current;
        String stringCode = codeTextarea.getText();
        StringReader readerCode = new StringReader(stringCode);
        LexiconParser parser = new LexiconParser(readerCode);
        tokens = new ArrayList<>();

        try {
            while (true) {
                parser.next_token();
                current = parser.yylex();
                if (current.getToken() == sym.EOF) {
                    break;
                } else {
                    tokens.add(current);
                }
            }
        } catch (IOException ex) {
            Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public SyntacticParser getAllErrorsAndTokens() {
        errors = new ArrayList<>();
        tokens = new ArrayList<>();
        String stringCode = codeTextarea.getText();
        StringReader readerCode = new StringReader(stringCode);
        CustomScanner scannerCode = new CustomScanner(readerCode, tokens);
        SyntacticParser parser = new SyntacticParser(scannerCode, errors);

        try {
            parser.start();
        } catch (Exception ex) {
            Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
        }

        myDocumentFilter.ignoredTokens = parser.getTokenIgnorados();
        return parser;
    }

    public void getMachineCode(SyntacticParser parser) {
        machineCode = parser.getMachineCode().getInstructions();
    }

    public void getInterpreter(SyntacticParser parser) {
        if (errors.isEmpty()) {
            tabPanelBottom.setSelectedIndex(3);
            executionTextArea.setText("");
            Interpreter interpreter = new Interpreter(parser.getMachineCode().getInstructions(), this);
            interpreter.run();
            if (executionTextArea.getText().equals("")) {
                executionTextArea.setText("O código inserido não contém nenhuma interação com o usuário (read/write)!");
            }
        } else {
            tabPanelBottom.setSelectedIndex(1);
        }
    }

    @Override
    public int readInt() {
        String input = JOptionPane.showInputDialog(this, "Digite um número inteiro", "0");
        try {
            int number = Integer.valueOf(input);
            executionTextArea.append("Entrada: " + number + "\n");
            return number;
        } catch (NumberFormatException n) {
            JOptionPane.showMessageDialog(this, "O valor inserido está incorreto!", "Erro", JOptionPane.ERROR_MESSAGE);
            return readInt();
        }
    }

    @Override
    public void printInt(int number) {
        executionTextArea.append("Saida: " + number + "\n");
    }

    private class PaintTableCellRenderer extends DefaultTableCellRenderer {

        @Override
        public Component getTableCellRendererComponent(
                JTable table,
                Object value,
                boolean isSelected,
                boolean hasFocus,
                int row,
                int column
        ) {
            super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

            Boolean isWrong = Boolean.valueOf((String) table.getValueAt(row, 5));
            Color lightGrayColor = new Color(240, 240, 240);
            Color blackColor = new Color(40, 40, 40);

            if (isWrong == true) {
                setBackground(Color.RED);
                setForeground(Color.WHITE);
            } else {
                if (isSelected == true) {
                    setBackground(getBackground());
                    setForeground(getForeground());
                } else {
                    if (row % 2 == 0) {
                        setBackground(Color.WHITE);
                    } else {
                        setBackground(lightGrayColor);
                    }
                    setForeground(blackColor);
                }
            }
            return this;
        }
    }

    private class CustomDocumentFilter extends DocumentFilter {

        private final StyledDocument styledDocument = codeTextarea.getStyledDocument();
        private final StyleContext styleContext = StyleContext.getDefaultStyleContext();
        private ArrayList<Token> ignoredTokens;
        private final AttributeSet blueAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.BLUE);
        private final AttributeSet blackAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.BLACK);
        private final AttributeSet greenAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, new Color(0, 153, 0));
        private final AttributeSet redAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.RED);
        private final AttributeSet pinkAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, new Color(255, 0, 255));
        private final AttributeSet grayAttributeSet = styleContext.addAttribute(styleContext.getEmptySet(), StyleConstants.Foreground, Color.gray);

        @Override
        public void insertString(DocumentFilter.FilterBypass fb, int offset, String text, AttributeSet attributeSet) throws BadLocationException {
            super.insertString(fb, offset, text, attributeSet);
            handleTextChanged();
        }

        @Override
        public void remove(DocumentFilter.FilterBypass fb, int offset, int length) throws BadLocationException {
            super.remove(fb, offset, length);
            handleTextChanged();
        }

        @Override
        public void replace(DocumentFilter.FilterBypass fb, int offset, int length, String text, AttributeSet attributeSet) throws BadLocationException {
            super.replace(fb, offset, length, text, attributeSet);
            handleTextChanged();
        }

        /**
         * Runs your updates later, not during the event notification.
         */
        private void handleTextChanged() {
            SwingUtilities.invokeLater(() -> {
                updateTextStyles();
            });
        }

        private void updateTextStyles() {
            // Clear existing styles
            styledDocument.setCharacterAttributes(0, codeTextarea.getText().length(), blackAttributeSet, true);
            LexiconParser parser = new LexiconParser(new StringReader(codeTextarea.getText()));
            parser.tokens(true);
            Token currentToken;
            ArrayList<Token> tokensCopy = (ignoredTokens != null ? (ArrayList<Token>) ignoredTokens.clone() : null);

            try {
                while (true) {
                    parser.next_token();
                    currentToken = parser.yylex();
                    if (currentToken.getToken() == sym.EOF) {
                        break;
                    }
                    AttributeSet ts = blackAttributeSet;
                    if (currentToken.getToken() >= 2 && currentToken.getToken() <= 15) {
                        ts = blueAttributeSet;
                    } else if ((currentToken.getToken() >= 22 && currentToken.getToken() <= 34)) {
                        ts = redAttributeSet;
                    } else if (currentToken.getToken() == 35 || currentToken.getToken() == 36) {
                        ts = pinkAttributeSet;
                    } else if (currentToken.getToken() == 37) {
                        ts = greenAttributeSet;
                    } else if (currentToken.getToken() >= 40 && currentToken.getToken() <= 42) {
                        ts = grayAttributeSet;
                    }
                    if (ignoredTokens != null && ignoredTokens.contains(currentToken)) {
                        ignoredTokens.remove(currentToken);
                        ts = styleContext.addAttribute(ts, StyleConstants.Underline, true);
                    }
                    styledDocument.setCharacterAttributes(
                            currentToken.getOffset() - currentToken.getRow(),
                            currentToken.getLexeme().length(),
                            ts,
                            false
                    );
                }
            } catch (IOException ex) {
                Logger.getLogger(Principal.class.getName()).log(Level.SEVERE, null, ex);
            }
            ignoredTokens = tokensCopy;
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane codeScrollPanel;
    private javax.swing.JTextPane codeTextarea;
    private javax.swing.JPanel errorsPanel;
    private javax.swing.JScrollPane errorsScrollPanel;
    private javax.swing.JTable errorsTable;
    private javax.swing.JPanel executionPanel;
    private javax.swing.JScrollPane executionScrollPanel;
    private javax.swing.JTextArea executionTextArea;
    private javax.swing.JMenuItem itemInterpreter;
    private javax.swing.JMenuItem itemLexiconParser;
    private javax.swing.JMenuItem itemLoadFile;
    private javax.swing.JMenuItem itemMachineCode;
    private javax.swing.JMenuItem itemSyntacticParser;
    private javax.swing.JTable machineCodeTable;
    private javax.swing.JPanel machinePanel;
    private javax.swing.JScrollPane machineScrollPanel;
    private javax.swing.JMenuBar menuBarTop;
    private javax.swing.JMenu menuExecutar;
    private javax.swing.JMenu menuFile;
    private javax.swing.JTabbedPane tabPanelBottom;
    private javax.swing.JPanel tokensPanel;
    private javax.swing.JScrollPane tokensScrollPanel;
    private javax.swing.JTable tokensTable;
    // End of variables declaration//GEN-END:variables
}
